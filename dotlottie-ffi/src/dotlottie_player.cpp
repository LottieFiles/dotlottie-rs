/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "dotlottie_player.hpp"

namespace dotlottie_player {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_dotlottie_player_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error("UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_func_create_default_config() != 22012) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_func_create_default_layout() != 21428) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_active_animation_id() != 57608) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_active_theme_id() != 60173) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_animation_size() != 50170) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_buffer_len() != 33793) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_buffer_ptr() != 30907) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_clear() != 26373) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_config() != 46335) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_current_frame() != 42425) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_duration() != 3831) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_is_complete() != 51890) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_is_loaded() != 20186) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_is_paused() != 56658) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_is_playing() != 45670) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_is_stopped() != 28412) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_animation() != 52252) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_animation_data() != 63827) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_animation_path() != 5718) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_dotlottie_data() != 3402) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_state_machine() != 2360) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_state_machine_data() != 481) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_theme() != 58256) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_load_theme_data() != 49777) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_loop_count() != 14780) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_manifest_string() != 60193) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_markers() != 46926) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_pause() != 16452) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_play() != 54931) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_post_serialized_event() != 56470) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_render() != 34602) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_request_frame() != 39939) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_resize() != 16787) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_seek() != 60656) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_segment_duration() != 38024) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_config() != 10331) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_frame() != 44086) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_state_machine_boolean_context() != 53110) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_state_machine_numeric_context() != 60196) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_state_machine_string_context() != 11860) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_set_viewport() != 29505) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_start_state_machine() != 12092) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_state_machine_framework_setup() != 9890) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_stop() != 25240) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_stop_state_machine() != 18978) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_method_dotlottieplayer_total_frames() != 12091) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_dotlottie_player_checksum_constructor_dotlottieplayer_new() != 25412) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
}

template <typename F>
void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F, typename EF, typename... Args, typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = { 0 };

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_dotlottie_player_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_dotlottie_player_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = { 0 };

    ffi_dotlottie_player_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}


uint32_t FfiConverterUInt32::lift(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::lower(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::read(RustStream &stream) {
    uint32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt32::write(RustStream &stream, uint32_t val) {
    stream << val;
}

int32_t FfiConverterUInt32::allocation_size(uint32_t) {
    return static_cast<int32_t>(sizeof(uint32_t));
}
int32_t FfiConverterInt32::lift(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::lower(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::read(RustStream &stream) {
    int32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt32::write(RustStream &stream, int32_t val) {
    stream << val;
}

int32_t FfiConverterInt32::allocation_size(int32_t) {
    return static_cast<int32_t>(sizeof(int32_t));
}
uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

int32_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<int32_t>(sizeof(uint64_t));
}
float FfiConverterFloat::lift(float val) {
    return val;
}

float FfiConverterFloat::lower(float val) {
    return val;
}

float FfiConverterFloat::read(RustStream &stream) {
    float ret;
    stream >> ret;

    return ret;
}

void FfiConverterFloat::write(RustStream &stream, float val) {
    stream << val;
}

int32_t FfiConverterFloat::allocation_size(float) {
    return static_cast<int32_t>(sizeof(float));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

int32_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes { len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data())) };

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}

std::vector<uint8_t> FfiConverterBytes::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterBytes::lower(const std::vector<uint8_t> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<uint8_t> FfiConverterBytes::read(RustStream &stream) {
    std::vector<uint8_t> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        uint8_t elem;
        stream >> elem;
        ret.push_back(elem);
    }

    return ret;
}

void FfiConverterBytes::write(RustStream &stream, const std::vector<uint8_t> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        stream << elem;
    }
}

int32_t FfiConverterBytes::allocation_size(const std::vector<uint8_t> &val) {
    return static_cast<int32_t>(sizeof(int32_t) + sizeof(uint8_t) * val.size());
}
} // namespace uniffi










DotLottiePlayer::DotLottiePlayer(void *ptr): instance(ptr) {}


std::shared_ptr<DotLottiePlayer> DotLottiePlayer::init(const Config &config) {
    return std::shared_ptr<DotLottiePlayer>(
        new DotLottiePlayer(uniffi::rust_call(
        uniffi_dotlottie_player_fn_constructor_dotlottieplayer_new,
        nullptr, uniffi::FfiConverterTypeConfig::lower(config)))
    );
}

std::string DotLottiePlayer::active_animation_id() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_active_animation_id,
        nullptr,
        this->instance));
}
std::string DotLottiePlayer::active_theme_id() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_active_theme_id,
        nullptr,
        this->instance));
}
std::vector<float> DotLottiePlayer::animation_size() {
    return uniffi::FfiConverterSequenceFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_animation_size,
        nullptr,
        this->instance));
}
uint64_t DotLottiePlayer::buffer_len() {
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_buffer_len,
        nullptr,
        this->instance));
}
uint64_t DotLottiePlayer::buffer_ptr() {
    return uniffi::FfiConverterUInt64::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_buffer_ptr,
        nullptr,
        this->instance));
}
void DotLottiePlayer::clear() {
    uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_clear,
        nullptr,
        this->instance);
}
Config DotLottiePlayer::config() {
    return uniffi::FfiConverterTypeConfig::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_config,
        nullptr,
        this->instance));
}
float DotLottiePlayer::current_frame() {
    return uniffi::FfiConverterFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_current_frame,
        nullptr,
        this->instance));
}
float DotLottiePlayer::duration() {
    return uniffi::FfiConverterFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_duration,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::is_complete() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_is_complete,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::is_loaded() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_is_loaded,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::is_paused() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_is_paused,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::is_playing() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_is_playing,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::is_stopped() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_is_stopped,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::load_animation(const std::string &animation_id, uint32_t width, uint32_t height) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_animation,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(animation_id), uniffi::FfiConverterUInt32::lower(width), uniffi::FfiConverterUInt32::lower(height)));
}
bool DotLottiePlayer::load_animation_data(const std::string &animation_data, uint32_t width, uint32_t height) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_animation_data,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(animation_data), uniffi::FfiConverterUInt32::lower(width), uniffi::FfiConverterUInt32::lower(height)));
}
bool DotLottiePlayer::load_animation_path(const std::string &animation_path, uint32_t width, uint32_t height) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_animation_path,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(animation_path), uniffi::FfiConverterUInt32::lower(width), uniffi::FfiConverterUInt32::lower(height)));
}
bool DotLottiePlayer::load_dotlottie_data(const std::vector<uint8_t> &file_data, uint32_t width, uint32_t height) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_dotlottie_data,
        nullptr,
        this->instance, uniffi::FfiConverterBytes::lower(file_data), uniffi::FfiConverterUInt32::lower(width), uniffi::FfiConverterUInt32::lower(height)));
}
bool DotLottiePlayer::load_state_machine(const std::string &str) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_state_machine,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(str)));
}
bool DotLottiePlayer::load_state_machine_data(const std::string &state_machine) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_state_machine_data,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(state_machine)));
}
bool DotLottiePlayer::load_theme(const std::string &theme_id) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_theme,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(theme_id)));
}
bool DotLottiePlayer::load_theme_data(const std::string &theme_data) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_load_theme_data,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(theme_data)));
}
uint32_t DotLottiePlayer::loop_count() {
    return uniffi::FfiConverterUInt32::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_loop_count,
        nullptr,
        this->instance));
}
std::string DotLottiePlayer::manifest_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_manifest_string,
        nullptr,
        this->instance));
}
std::vector<Marker> DotLottiePlayer::markers() {
    return uniffi::FfiConverterSequenceTypeMarker::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_markers,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::pause() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_pause,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::play() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_play,
        nullptr,
        this->instance));
}
int32_t DotLottiePlayer::post_serialized_event(const std::string &event) {
    return uniffi::FfiConverterInt32::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_post_serialized_event,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(event)));
}
bool DotLottiePlayer::render() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_render,
        nullptr,
        this->instance));
}
float DotLottiePlayer::request_frame() {
    return uniffi::FfiConverterFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_request_frame,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::resize(uint32_t width, uint32_t height) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_resize,
        nullptr,
        this->instance, uniffi::FfiConverterUInt32::lower(width), uniffi::FfiConverterUInt32::lower(height)));
}
bool DotLottiePlayer::seek(float no) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_seek,
        nullptr,
        this->instance, uniffi::FfiConverterFloat::lower(no)));
}
float DotLottiePlayer::segment_duration() {
    return uniffi::FfiConverterFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_segment_duration,
        nullptr,
        this->instance));
}
void DotLottiePlayer::set_config(const Config &config) {
    uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_config,
        nullptr,
        this->instance, uniffi::FfiConverterTypeConfig::lower(config));
}
bool DotLottiePlayer::set_frame(float no) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_frame,
        nullptr,
        this->instance, uniffi::FfiConverterFloat::lower(no)));
}
bool DotLottiePlayer::set_state_machine_boolean_context(const std::string &key, bool value) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_state_machine_boolean_context,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(key), uniffi::FfiConverterBool::lower(value)));
}
bool DotLottiePlayer::set_state_machine_numeric_context(const std::string &key, float value) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_state_machine_numeric_context,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(key), uniffi::FfiConverterFloat::lower(value)));
}
bool DotLottiePlayer::set_state_machine_string_context(const std::string &key, const std::string &value) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_state_machine_string_context,
        nullptr,
        this->instance, uniffi::FfiConverterString::lower(key), uniffi::FfiConverterString::lower(value)));
}
bool DotLottiePlayer::set_viewport(int32_t x, int32_t y, int32_t w, int32_t h) {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_set_viewport,
        nullptr,
        this->instance, uniffi::FfiConverterInt32::lower(x), uniffi::FfiConverterInt32::lower(y), uniffi::FfiConverterInt32::lower(w), uniffi::FfiConverterInt32::lower(h)));
}
bool DotLottiePlayer::start_state_machine() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_start_state_machine,
        nullptr,
        this->instance));
}
std::vector<std::string> DotLottiePlayer::state_machine_framework_setup() {
    return uniffi::FfiConverterSequenceString::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_state_machine_framework_setup,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::stop() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_stop,
        nullptr,
        this->instance));
}
bool DotLottiePlayer::stop_state_machine() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_stop_state_machine,
        nullptr,
        this->instance));
}
float DotLottiePlayer::total_frames() {
    return uniffi::FfiConverterFloat::lift(uniffi::rust_call(
        uniffi_dotlottie_player_fn_method_dotlottieplayer_total_frames,
        nullptr,
        this->instance));
}

DotLottiePlayer::~DotLottiePlayer() {
    uniffi::rust_call(
        uniffi_dotlottie_player_fn_free_dotlottieplayer,
        nullptr,
        this->instance
    );
}









namespace uniffi {







std::shared_ptr<DotLottiePlayer> FfiConverterDotLottiePlayer::lift(void *ptr) {
    return std::shared_ptr<DotLottiePlayer>(new DotLottiePlayer(ptr));
}

void *FfiConverterDotLottiePlayer::lower(const std::shared_ptr<DotLottiePlayer> &obj) {
    return obj->instance;
}

std::shared_ptr<DotLottiePlayer> FfiConverterDotLottiePlayer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<DotLottiePlayer>(new DotLottiePlayer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDotLottiePlayer::write(RustStream &stream, const std::shared_ptr<DotLottiePlayer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDotLottiePlayer::allocation_size(const std::shared_ptr<DotLottiePlayer> &) {
    return 8;
}


Config FfiConverterTypeConfig::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConfig::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConfig::lower(const Config &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConfig::write(stream, val);

    return std::move(buf);
}

Config FfiConverterTypeConfig::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterTypeMode::read(stream),
        FfiConverterFloat::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterSequenceFloat::read(stream),
        FfiConverterUInt32::read(stream),
        FfiConverterTypeLayout::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeConfig::write(RustStream &stream, const Config &val) {
    FfiConverterBool::write(stream, val.autoplay);
    FfiConverterBool::write(stream, val.loop_animation);
    FfiConverterTypeMode::write(stream, val.mode);
    FfiConverterFloat::write(stream, val.speed);
    FfiConverterBool::write(stream, val.use_frame_interpolation);
    FfiConverterSequenceFloat::write(stream, val.segment);
    FfiConverterUInt32::write(stream, val.background_color);
    FfiConverterTypeLayout::write(stream, val.layout);
    FfiConverterString::write(stream, val.marker);
}

int32_t FfiConverterTypeConfig::allocation_size(const Config &val) {
    return 
        FfiConverterBool::allocation_size(val.autoplay) +
        FfiConverterBool::allocation_size(val.loop_animation) +
        FfiConverterTypeMode::allocation_size(val.mode) +
        FfiConverterFloat::allocation_size(val.speed) +
        FfiConverterBool::allocation_size(val.use_frame_interpolation) +
        FfiConverterSequenceFloat::allocation_size(val.segment) +
        FfiConverterUInt32::allocation_size(val.background_color) +
        FfiConverterTypeLayout::allocation_size(val.layout) +
        FfiConverterString::allocation_size(val.marker);
}


Layout FfiConverterTypeLayout::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeLayout::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeLayout::lower(const Layout &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeLayout::write(stream, val);

    return std::move(buf);
}

Layout FfiConverterTypeLayout::read(RustStream &stream) {
    return {
        FfiConverterTypeFit::read(stream),
        FfiConverterSequenceFloat::read(stream)
    };
}

void FfiConverterTypeLayout::write(RustStream &stream, const Layout &val) {
    FfiConverterTypeFit::write(stream, val.fit);
    FfiConverterSequenceFloat::write(stream, val.align);
}

int32_t FfiConverterTypeLayout::allocation_size(const Layout &val) {
    return 
        FfiConverterTypeFit::allocation_size(val.fit) +
        FfiConverterSequenceFloat::allocation_size(val.align);
}


Marker FfiConverterTypeMarker::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMarker::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMarker::lower(const Marker &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMarker::write(stream, val);

    return std::move(buf);
}

Marker FfiConverterTypeMarker::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterFloat::read(stream),
        FfiConverterFloat::read(stream)
    };
}

void FfiConverterTypeMarker::write(RustStream &stream, const Marker &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterFloat::write(stream, val.time);
    FfiConverterFloat::write(stream, val.duration);
}

int32_t FfiConverterTypeMarker::allocation_size(const Marker &val) {
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterFloat::allocation_size(val.time) +
        FfiConverterFloat::allocation_size(val.duration);
}


Fit FfiConverterTypeFit::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFit::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFit::lower(const Fit &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFit::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFit::write(stream, val);

    return std::move(buf);
}

Fit FfiConverterTypeFit::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return Fit::kContain;
        
    case 2:
        return Fit::kFill;
        
    case 3:
        return Fit::kCover;
        
    case 4:
        return Fit::kFitWidth;
        
    case 5:
        return Fit::kFitHeight;
        
    case 6:
        return Fit::kNone;
        
    default:
        throw std::runtime_error("No matching Fit variant");
    }
}

void FfiConverterTypeFit::write(RustStream &stream, const Fit &val) {
    switch (val) {
        
    case Fit::kContain:
        stream << static_cast<int32_t>(1);
        break;
        
    case Fit::kFill:
        stream << static_cast<int32_t>(2);
        break;
        
    case Fit::kCover:
        stream << static_cast<int32_t>(3);
        break;
        
    case Fit::kFitWidth:
        stream << static_cast<int32_t>(4);
        break;
        
    case Fit::kFitHeight:
        stream << static_cast<int32_t>(5);
        break;
        
    case Fit::kNone:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching Fit variant");
    }
}

int32_t FfiConverterTypeFit::allocation_size(const Fit &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


Mode FfiConverterTypeMode::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMode::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMode::lower(const Mode &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeMode::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMode::write(stream, val);

    return std::move(buf);
}

Mode FfiConverterTypeMode::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return Mode::kForward;
        
    case 2:
        return Mode::kReverse;
        
    case 3:
        return Mode::kBounce;
        
    case 4:
        return Mode::kReverseBounce;
        
    default:
        throw std::runtime_error("No matching Mode variant");
    }
}

void FfiConverterTypeMode::write(RustStream &stream, const Mode &val) {
    switch (val) {
        
    case Mode::kForward:
        stream << static_cast<int32_t>(1);
        break;
        
    case Mode::kReverse:
        stream << static_cast<int32_t>(2);
        break;
        
    case Mode::kBounce:
        stream << static_cast<int32_t>(3);
        break;
        
    case Mode::kReverseBounce:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching Mode variant");
    }
}

int32_t FfiConverterTypeMode::allocation_size(const Mode &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


std::vector<float> FfiConverterSequenceFloat::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceFloat::lower(const std::vector<float> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<float> FfiConverterSequenceFloat::read(RustStream &stream) {
    std::vector<float> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterFloat::read(stream));
    }

    return ret;
}

void FfiConverterSequenceFloat::write(RustStream &stream, const std::vector<float> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterFloat::write(stream, elem);
    }
}

int32_t FfiConverterSequenceFloat::allocation_size(const std::vector<float> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterFloat::allocation_size(elem);
    }

    return size;
}


std::vector<std::string> FfiConverterSequenceString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceString::lower(const std::vector<std::string> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<std::string> FfiConverterSequenceString::read(RustStream &stream) {
    std::vector<std::string> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterString::read(stream));
    }

    return ret;
}

void FfiConverterSequenceString::write(RustStream &stream, const std::vector<std::string> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterString::write(stream, elem);
    }
}

int32_t FfiConverterSequenceString::allocation_size(const std::vector<std::string> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterString::allocation_size(elem);
    }

    return size;
}


std::vector<Marker> FfiConverterSequenceTypeMarker::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeMarker::lower(const std::vector<Marker> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Marker> FfiConverterSequenceTypeMarker::read(RustStream &stream) {
    std::vector<Marker> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeMarker::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeMarker::write(RustStream &stream, const std::vector<Marker> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeMarker::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeMarker::allocation_size(const std::vector<Marker> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeMarker::allocation_size(elem);
    }

    return size;
}

}

Config create_default_config() {
    auto ret = uniffi::rust_call(
        uniffi_dotlottie_player_fn_func_create_default_config,
        nullptr);

    return uniffi::FfiConverterTypeConfig::lift(ret);
}


Layout create_default_layout() {
    auto ret = uniffi::rust_call(
        uniffi_dotlottie_player_fn_func_create_default_layout,
        nullptr);

    return uniffi::FfiConverterTypeLayout::lift(ret);
}
} // namespace dotlottie_player