<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <canvas id="canvas" style="width: 250px; height: 250px"></canvas>
    <button id="resize-sm">Resize (sm)</button>
    <button id="resize-lg">Resize (lg)</button>
    <script type="module">
      import createDotLottiePlayerModule from "./release/wasm/DotLottiePlayer.js";

      const RendererBackend = {
        SOFTWARE: "software",
        WEBGPU: "webgpu",
        WEBGL: "webgl",
      };

      class Player {
        constructor(canvas, options = {}) {
          this.canvas = canvas;
          this.options = {
            autoplay: true,
            loopAnimation: true,
            backend: RendererBackend.SOFTWARE,
            ...options,
          };
          this.backend = this.options.backend;
          this.ctx = null;
          this.Module = null;
          this.dotLottiePlayer = null;
          this.frameBufferPtr = null;
          this.frameBufferSize = 0;
          this.frameBufferView = null;
          this.imageData = null;
          this.width = 0;
          this.height = 0;
          this.animationId = null;
          this.isLoaded = false;

          // WebGPU specific properties
          this.adapter = null;
          this.device = null;

          // WebGL specific properties
          this.glContext = null;
        }

        async initialize() {
          // Initialize WebGPU device first if using WebGPU backend
          let webgpuDevice = null;
          if (this.backend === RendererBackend.WEBGPU) {
            if (!navigator.gpu) {
              throw new Error("WebGPU not supported by browser");
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
              throw new Error("WebGPU adapter not found");
            }

            webgpuDevice = await adapter.requestDevice();
            this.device = webgpuDevice;

            console.log(this.device);
          }

          this.Module = await createDotLottiePlayerModule({
            locateFile: (path, prefix) => {
              if (path.endsWith(".wasm")) {
                return `release/wasm/${path}`;
              }
              return `${prefix}${path}`;
            },
            preinitializedWebGPUDevice: this.device,
          });

          await this._setupCanvas();
          this._initializePlayer();
          return this;
        }

        async _setupCanvas() {
          const { height: clientHeight, width: clientWidth } =
            this.canvas.getBoundingClientRect();

          this.canvas.width = clientWidth * window.devicePixelRatio;
          this.canvas.height = clientHeight * window.devicePixelRatio;

          this.width = this.canvas.width;
          this.height = this.canvas.height;

          if (this.backend === RendererBackend.SOFTWARE) {
            this.ctx = this.canvas.getContext("2d");
            this._initializeFrameBuffer();
          } else if (this.backend === RendererBackend.WEBGPU) {
            await this._initializeWebGPU();
          } else if (this.backend === RendererBackend.WEBGL) {
            this._initializeWebGL();
          }
        }

        _initializeFrameBuffer() {
          if (this.frameBufferPtr) {
            this.Module._free(this.frameBufferPtr);
          }

          this.frameBufferSize = this.width * this.height * 4;
          this.frameBufferPtr = this.Module._malloc(this.frameBufferSize);

          this.imageData = this.ctx.createImageData(this.width, this.height);

          this.frameBufferView = new Uint8ClampedArray(
            this.Module.HEAPU8.buffer,
            this.frameBufferPtr,
            this.frameBufferSize
          );
        }

        async _initializeWebGPU() {
          if (this.ctx) return;
          // WebGPU device is already initialized in initialize() method
          // Just set up the canvas context and configure it

          // Get WebGPU context
          this.ctx = this.canvas.getContext("webgpu");

          if (!this.ctx) {
            throw new Error("WebGPU canvas context not supported");
          }
        }

        _initializeWebGL() {
          if (this.ctx) return;

          this.ctx =
            this.canvas.getContext("webgl2") || this.canvas.getContext("webgl");

          if (!this.ctx) {
            throw new Error("WebGL not supported by browser");
          }

          this.glContext = this.Module.webgl_context_create("#canvas");

          if (this.glContext == 0) {
            console.error("Couldn't create webgl context");
            return;
          }

          console.log("WebGL context initialized:", this.ctx);
        }

        _initializePlayer() {
          this.dotLottiePlayer = new this.Module.DotLottiePlayer({
            ...this.Module.createDefaultConfig(),
            ...this.options,
          });

          if (this.backend === RendererBackend.SOFTWARE) {
            this.dotLottiePlayer.setSwTarget(
              this.frameBufferPtr,
              this.width,
              this.width,
              this.height,
              this.Module.ColorSpace.ABGR8888S
            );
          } else if (this.backend === RendererBackend.WEBGPU) {
            // WebGPU backend implementation
            //
            // Get WebGPU handles from the already configured context
            // The device was already initialized during Module creation

            this.deviceHandle = this.Module.webgpu_get_device();
            this.instanceHandle = this.Module.webgpu_get_instance();
            this.surfaceHandle = this.Module.webgpu_get_surface("#canvas");

            console.log(
              "WebGPU handles - device:",
              this.deviceHandle,
              "instance:",
              this.instanceHandle,
              "surface:",
              this.surfaceHandle
            );

            console.log(
              "setwgtarget result:",
              this.dotLottiePlayer.setWgTarget(
                this.deviceHandle,
                this.instanceHandle,
                this.surfaceHandle,
                this.width,
                this.height,
                this.Module.ColorSpace.ABGR8888S,
                0
              )
            );
          } else if (this.backend === RendererBackend.WEBGL) {
            // WebGL backend implementation
            // Set up WebGL target using the canvas selector
            console.log("Setting up WebGL target for canvas:", "#canvas");

            const result = this.dotLottiePlayer.setGlTarget(
              this.glContext,
              0,
              this.width,
              this.height,
              this.Module.ColorSpace.ABGR8888S
            );

            console.log("setGlTarget result:", result);
          }
        }
        async loadAnimation(url) {
          const data = await fetch(url).then((res) => res.arrayBuffer());

          this.isLoaded = this.dotLottiePlayer.loadDotLottieData(
            data,
            this.width,
            this.height
          );

          if (!this.isLoaded) {
            console.error("Failed to load Lottie data.");
            return false;
          }

          console.log("Animation size:", {
            width: this.dotLottiePlayer.animationSize().get(0),
            height: this.dotLottiePlayer.animationSize().get(1),
          });

          return this.isLoaded;
        }

        startAnimation() {
          if (!this.isLoaded) {
            console.warn("Animation not loaded. Call loadAnimation() first.");
            return;
          }

          console.log("Starting animation loop");
          this._animationLoop();
        }

        stopAnimation() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }

        _render() {
          if (this.dotLottiePlayer.tick()) {
            if (this.backend === RendererBackend.SOFTWARE) {
              this.imageData.data.set(this.frameBufferView);
              this.ctx.putImageData(this.imageData, 0, 0);
            } else if (this.backend === RendererBackend.WEBGPU) {
              // WebGPU rendering is handled by the native layer
              // The tick() call already submitted the render commands
              // No additional JavaScript rendering needed
            } else if (this.backend === RendererBackend.WEBGL) {
              // WebGL rendering is handled by the native layer
              // The tick() call already submitted the render commands to the WebGL context
              // No additional JavaScript rendering needed
            }
          }
        }

        _animationLoop() {
          this._render();
          this.animationId = requestAnimationFrame(() => this._animationLoop());
        }

        async resize(newWidth, newHeight) {
          this.canvas.style.width = `${newWidth}px`;
          this.canvas.style.height = `${newHeight}px`;

          await this._setupCanvas();

          let setTargetResult;
          if (this.backend === RendererBackend.SOFTWARE) {
            setTargetResult = this.dotLottiePlayer.setSwTarget(
              this.frameBufferPtr,
              this.width,
              this.width,
              this.height,
              this.Module.ColorSpace.ABGR8888S
            );
          } else if (this.backend === RendererBackend.WEBGPU) {
            setTargetResult = this.dotLottiePlayer.setWgTarget(
              this.deviceHandle,
              this.instanceHandle,
              this.surfaceHandle,
              this.width,
              this.height,
              this.Module.ColorSpace.ABGR8888S,
              0
            );
          } else if (this.backend === RendererBackend.WEBGL) {
            setTargetResult = this.dotLottiePlayer.setGlTarget(
              this.glContext,
              0,
              this.width,
              this.height,
              this.Module.ColorSpace.ABGR8888S
            );
          }

          const resizeResult = this.dotLottiePlayer.resize(
            this.width,
            this.height
          );

          console.log("Resize results:", { setTargetResult, resizeResult });
        }

        cleanup() {
          this.stopAnimation();

          if (this.backend === RendererBackend.SOFTWARE) {
            if (this.frameBufferPtr !== null) {
              this.Module._free(this.frameBufferPtr);
              this.frameBufferPtr = null;
            }
          } else if (this.backend === RendererBackend.WEBGPU) {
            if (this.device) {
              this.device.destroy();
              this.device = null;
            }
          } else if (this.backend === RendererBackend.WEBGL) {
            // WebGL context cleanup is handled automatically by the browser
            // when the canvas is removed or the page unloads
            this.Module.webgl_context_destroy(this.glContext);
            this.glContext = null;
            this.ctx = null;
          }

          if (this.dotLottiePlayer) {
            this.dotLottiePlayer.delete();
            this.dotLottiePlayer = null;
          }
        }
      }

      const canvas = document.querySelector("canvas");
      // Switch between RendererBackend.SOFTWARE, RendererBackend.WEBGPU, and RendererBackend.WEBGL
      const player = new Player(canvas, {
        backend: RendererBackend.SOFTWARE,
      });

      await player.initialize();

      const loaded = await player.loadAnimation(
        "./examples/demo-player/src/emoji.lottie"
      );

      if (loaded) {
        player.startAnimation();
      }

      document
        .getElementById("resize-sm")
        .addEventListener("click", async () => {
          await player.resize(250, 250);
        });

      document
        .getElementById("resize-lg")
        .addEventListener("click", async () => {
          await player.resize(500, 500);
        });

      window.addEventListener("beforeunload", () => {
        player.cleanup();
      });
    </script>
  </body>
</html>
